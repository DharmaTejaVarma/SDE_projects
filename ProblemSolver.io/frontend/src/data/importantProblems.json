[
  {
    "id": "1",
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "category": "arrays",
    "difficulty": "easy",
    "constraints": "2 <= nums.length <= 10^4, -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9",
    "sampleInput": "nums = [2,7,11,15], target = 9",
    "sampleOutput": "[0,1]",
    "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1].",
    "testCases": [
      {
        "input": "[2,7,11,15]\n9",
        "expectedOutput": "[0,1]"
      },
      {
        "input": "[3,2,4]\n6",
        "expectedOutput": "[1,2]"
      },
      {
        "input": "[3,3]\n6",
        "expectedOutput": "[0,1]"
      }
    ],
    "isImportant": true,
    "solution": {
      "python": {
        "code": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use a hash map to store numbers and their indices. For each number, check if its complement exists in the map."
      },
      "java": {
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use a HashMap to store numbers and their indices. For each number, check if its complement exists in the map."
      },
      "cpp": {
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (map.find(complement) != map.end()) {\n                return {map[complement], i};\n            }\n            map[nums[i]] = i;\n        }\n        return {};\n    }\n};",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use an unordered_map to store numbers and their indices. For each number, check if its complement exists in the map."
      }
    }
  },
  {
    "id": "2",
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    "category": "stacks",
    "difficulty": "easy",
    "constraints": "1 <= s.length <= 10^4, s consists of parentheses only '()[]{}'.",
    "sampleInput": "s = \"()\"",
    "sampleOutput": "true",
    "explanation": "The string is valid because open brackets are closed by the same type of brackets in the correct order.",
    "testCases": [
      {
        "input": "()",
        "expectedOutput": "true"
      },
      {
        "input": "()[]{}",
        "expectedOutput": "true"
      },
      {
        "input": "(]",
        "expectedOutput": "false"
      },
      {
        "input": "([)]",
        "expectedOutput": "false"
      },
      {
        "input": "{[]}",
        "expectedOutput": "true"
      }
    ],
    "isImportant": true,
    "solution": {
      "python": {
        "code": "def is_valid(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the top of the stack."
      },
      "java": {
        "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        Map<Character, Character> mapping = new HashMap<>();\n        mapping.put(')', '(');\n        mapping.put('}', '{');\n        mapping.put(']', '[');\n        for (char c : s.toCharArray()) {\n            if (mapping.containsKey(c)) {\n                char topElement = stack.empty() ? '#' : stack.pop();\n                if (!mapping.get(c).equals(topElement)) {\n                    return false;\n                }\n            } else {\n                stack.push(c);\n            }\n        }\n        return stack.empty();\n    }\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the top of the stack."
      },
      "cpp": {
        "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};\n        for (char c : s) {\n            if (mapping.count(c)) {\n                char topElement = st.empty() ? '#' : st.top();\n                st.pop();\n                if (mapping[c] != topElement) {\n                    return false;\n                }\n            } else {\n                st.push(c);\n            }\n        }\n        return st.empty();\n    }\n};",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "explanation": "Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the top of the stack."
      }
    }
  }
]